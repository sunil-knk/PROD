name: Auto Tag and Release (test/PROD only)

on:
  pull_request:
    types: [closed]
    branches:
      - test/PROD

permissions:
  contents: write

jobs:
  create-release:
    if: >
      github.event.pull_request.merged == true &&
      startsWith(github.event.pull_request.title, 'Sprint Release:')
    runs-on: ubuntu-latest
    env:
      REPO: ${{ github.repository }}
      TARGET_BRANCH: test/PROD
      GITHUB_API: https://api.github.com

    steps:
      - name: Checkout repository (all history & tags)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup git identity
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Determine next sprint tag
        id: next_tag
        run: |
          # pick latest sprint tag (sprint_N) and increment
          LATEST=$(git ls-remote --tags origin | awk -F/ '/refs\/tags\/sprint_/{print $NF}' | sort -V | tail -n1)
          if [ -z "$LATEST" ]; then
            NEXT_TAG="sprint_1"
          else
            NUM=$(echo "$LATEST" | grep -oE '[0-9]+$' || echo 0)
            NEXT_TAG="sprint_$((NUM + 1))"
          fi
          echo "next_tag=$NEXT_TAG" >> $GITHUB_OUTPUT
          echo "Determined NEXT_TAG: $NEXT_TAG"

      - name: Resolve commit SHA for test/PROD (remote)
        id: get_sha
        run: |
          # fetch the remote branch head (shallow)
          git fetch origin $TARGET_BRANCH --depth=1
          # get the commit SHA that HEAD of origin/test/PROD points to
          COMMIT_SHA=$(git rev-parse FETCH_HEAD)
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "Using commit SHA from $TARGET_BRANCH: $COMMIT_SHA"

      - name: Check if tag already exists remotely (idempotent)
        id: tag_exists
        run: |
          TAG=${{ steps.next_tag.outputs.next_tag }}
          # check remote tags
          if git ls-remote --tags origin "refs/tags/$TAG" | grep -q "$TAG"; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Tag $TAG already exists on remote. Skipping creation."
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Tag $TAG does not exist yet."
          fi

      - name: Create and push tag from test/PROD commit (if not exists)
        if: steps.tag_exists.outputs.exists == 'false'
        env:
          GITHUB_TOKEN: ${{ secrets.SUNIL2_TOKEN }}
        run: |
          TAG=${{ steps.next_tag.outputs.next_tag }}
          SHA=${{ steps.get_sha.outputs.commit_sha }}
          echo "Creating annotated tag $TAG at $SHA"
          git tag -a "$TAG" "$SHA" -m "Sprint release $TAG (from $TARGET_BRANCH $SHA)"
          # push using token (use x-access-token or personal token); GITHUB_TOKEN has push rights when permissions: contents write
          git push "https://x-access-token:${GITHUB_TOKEN}@github.com/${REPO}.git" "refs/tags/$TAG"

      - name: Create GitHub Release using API (tag must exist in repo)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          TAG: ${{ steps.next_tag.outputs.next_tag }}
          TARGET_SHA: ${{ steps.get_sha.outputs.commit_sha }}
        run: |
          # If tag already existed we still proceed to create a release (or you can skip if desired)
          API="$GITHUB_API/repos/$REPO/releases"
          PAYLOAD=$(jq -n \
            --arg tag "$TAG" \
            --arg target "$TARGET_SHA" \
            --arg name "Sprint Release $TAG" \
            --arg body "Release created from $TARGET_BRANCH commit: $TARGET_SHA\nTriggered by PR: ${{ github.event.pull_request.title }}" \
            '{ tag_name: $tag, target_commitish: $target, name: $name, body: $body, generate_release_notes: true, draft: false, prerelease: false }')

          echo "Creating release for $TAG pointing at $TARGET_SHA"
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "$API" \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD")

          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$RESPONSE" | head -n -1)

          echo "HTTP code: $HTTP_CODE"
          echo "$RESPONSE_BODY"

          if [ "$HTTP_CODE" -eq 201 ]; then
            echo "Release created successfully."
          elif [ "$HTTP_CODE" -eq 422 ]; then
            # 422 can mean release already exists for that tag â€” handle gracefully
            echo "Release creation failed with 422. Checking if release exists..."
            # try to find an existing release by tag
            EXISTING=$(curl -s -H "Authorization: token $GITHUB_TOKEN" -H "Accept: application/vnd.github+json" "https://api.github.com/repos/$REPO/releases/tags/$TAG")
            if echo "$EXISTING" | jq -e '.id' >/dev/null 2>&1; then
              echo "A release for $TAG already exists. Exiting OK."
            else
              echo "422 but no existing release detected. Response:"
              echo "$EXISTING"
              exit 1
            fi
          else
            echo "Failed to create release (HTTP $HTTP_CODE)"
            exit 1
          fi
